/****************************************************************************
 *
 * Copyright 2017 Samsung Electronics All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 *
 ****************************************************************************/

#include <stdio.h>
#include <fcntl.h>

#include "ocf_types.h"
#include "ocf_resources.h"
#include "ocf_request.h"
#include "ocf_rep.h"

#include "rt_manager.h"	//TODO: make header to ocf_...

/* Generating SVR dat files */
static const char TEMP_DOXM_PATH[] = "test_svr_doxm_server.dat";
static const char TEMP_CRED_PATH[] = "test_svr_cred_server.dat";
static const char TEMP_ACL2_PATH[] = "test_svr_acl2_server.dat";
static const char TEMP_PSTAT_PATH[] = "test_svr_pstat_server.dat";

const char TEMP_DOXM_DATA[] = {
	0xa7, 0x64, 0x6f, 0x78, 0x6d, 0x73, 0x81, 0x1b, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x66, 0x6f, 0x78, 0x6d, 0x73, 0x65, 0x6c, 0x1b,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x73, 0x63, 0x74,
	0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x65, 0x6f, 0x77,
	0x6e, 0x65, 0x64, 0xf5, 0x6a, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x75,
	0x75, 0x69, 0x64, 0x78, 0x24, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
	0x33, 0x2d, 0x33, 0x33, 0x33, 0x33, 0x2d, 0x33, 0x33, 0x33, 0x33, 0x2d,
	0x33, 0x33, 0x33, 0x33, 0x2d, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
	0x33, 0x33, 0x33, 0x33, 0x33, 0x6c, 0x64, 0x65, 0x76, 0x6f, 0x77, 0x6e,
	0x65, 0x72, 0x75, 0x75, 0x69, 0x64, 0x78, 0x24, 0x34, 0x34, 0x34, 0x34,
	0x34, 0x34, 0x34, 0x34, 0x2d, 0x34, 0x34, 0x34, 0x34, 0x2d, 0x34, 0x34,
	0x34, 0x34, 0x2d, 0x34, 0x34, 0x34, 0x34, 0x2d, 0x34, 0x34, 0x34, 0x34,
	0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x6a, 0x72, 0x6f, 0x77,
	0x6e, 0x65, 0x72, 0x75, 0x75, 0x69, 0x64, 0x78, 0x24, 0x34, 0x34, 0x34,
	0x34, 0x34, 0x34, 0x34, 0x34, 0x2d, 0x34, 0x34, 0x34, 0x34, 0x2d, 0x34,
	0x34, 0x34, 0x34, 0x2d, 0x34, 0x34, 0x34, 0x34, 0x2d, 0x34, 0x34, 0x34,
	0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34
};

const char TEMP_CRED_DATA[] = {
	0xa2, 0x65, 0x63, 0x72, 0x65, 0x64, 0x73, 0x82, 0xa5, 0x66, 0x63, 0x72,
	0x65, 0x64, 0x69, 0x64, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x6b, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x75, 0x75, 0x69,
	0x64, 0x78, 0x24, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x2d,
	0x31, 0x31, 0x31, 0x31, 0x2d, 0x31, 0x31, 0x31, 0x31, 0x2d, 0x31, 0x31,
	0x31, 0x31, 0x2d, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
	0x31, 0x31, 0x31, 0x68, 0x63, 0x72, 0x65, 0x64, 0x74, 0x79, 0x70, 0x65,
	0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x66, 0x70, 0x65,
	0x72, 0x69, 0x6f, 0x64, 0x78, 0x1f, 0x32, 0x30, 0x31, 0x35, 0x30, 0x36,
	0x33, 0x30, 0x54, 0x30, 0x36, 0x30, 0x30, 0x30, 0x30, 0x2f, 0x32, 0x30,
	0x39, 0x39, 0x30, 0x39, 0x32, 0x30, 0x54, 0x32, 0x32, 0x30, 0x30, 0x30,
	0x30, 0x6b, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x64, 0x61, 0x74,
	0x61, 0xa2, 0x68, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x74,
	0x6f, 0x69, 0x63, 0x2e, 0x73, 0x65, 0x63, 0x2e, 0x65, 0x6e, 0x63, 0x6f,
	0x64, 0x69, 0x6e, 0x67, 0x2e, 0x72, 0x61, 0x77, 0x64, 0x64, 0x61, 0x74,
	0x61, 0x50, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0xa5, 0x66, 0x63, 0x72, 0x65, 0x64,
	0x69, 0x64, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x6b,
	0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x75, 0x75, 0x69, 0x64, 0x78,
	0x24, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x2d, 0x32, 0x32,
	0x32, 0x32, 0x2d, 0x32, 0x32, 0x32, 0x32, 0x2d, 0x32, 0x32, 0x32, 0x32,
	0x2d, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
	0x32, 0x68, 0x63, 0x72, 0x65, 0x64, 0x74, 0x79, 0x70, 0x65, 0x1b, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x66, 0x70, 0x65, 0x72, 0x69,
	0x6f, 0x64, 0x78, 0x1f, 0x32, 0x30, 0x31, 0x35, 0x30, 0x36, 0x33, 0x30,
	0x54, 0x30, 0x36, 0x30, 0x30, 0x30, 0x30, 0x2f, 0x32, 0x30, 0x39, 0x39,
	0x30, 0x39, 0x32, 0x30, 0x54, 0x32, 0x32, 0x30, 0x30, 0x30, 0x30, 0x6b,
	0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x64, 0x61, 0x74, 0x61, 0xa2,
	0x68, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x74, 0x6f, 0x69,
	0x63, 0x2e, 0x73, 0x65, 0x63, 0x2e, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69,
	0x6e, 0x67, 0x2e, 0x72, 0x61, 0x77, 0x64, 0x64, 0x61, 0x74, 0x61, 0x50,
	0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
	0x42, 0x42, 0x42, 0x42, 0x6a, 0x72, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x75,
	0x75, 0x69, 0x64, 0x78, 0x24, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34,
	0x34, 0x2d, 0x34, 0x34, 0x34, 0x34, 0x2d, 0x34, 0x34, 0x34, 0x34, 0x2d,
	0x34, 0x34, 0x34, 0x34, 0x2d, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34,
	0x34, 0x34, 0x34, 0x34, 0x34
};

const char TEMP_ACL2_DATA[] = {
	0xa2, 0x67, 0x61, 0x63, 0x6c, 0x69, 0x73, 0x74, 0x32, 0x84, 0xa4, 0x65,
	0x61, 0x63, 0x65, 0x69, 0x64, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x67, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0xa1, 0x68,
	0x63, 0x6f, 0x6e, 0x6e, 0x74, 0x79, 0x70, 0x65, 0x6a, 0x61, 0x6e, 0x6f,
	0x6e, 0x2d, 0x63, 0x6c, 0x65, 0x61, 0x72, 0x69, 0x72, 0x65, 0x73, 0x6f,
	0x75, 0x72, 0x63, 0x65, 0x73, 0x84, 0xa1, 0x64, 0x68, 0x72, 0x65, 0x66,
	0x68, 0x2f, 0x6f, 0x69, 0x63, 0x2f, 0x72, 0x65, 0x73, 0xa1, 0x64, 0x68,
	0x72, 0x65, 0x66, 0x66, 0x2f, 0x6f, 0x69, 0x63, 0x2f, 0x64, 0xa1, 0x64,
	0x68, 0x72, 0x65, 0x66, 0x66, 0x2f, 0x6f, 0x69, 0x63, 0x2f, 0x70, 0xa1,
	0x64, 0x68, 0x72, 0x65, 0x66, 0x6d, 0x2f, 0x6f, 0x69, 0x63, 0x2f, 0x73,
	0x65, 0x63, 0x2f, 0x64, 0x6f, 0x78, 0x6d, 0x6a, 0x70, 0x65, 0x72, 0x6d,
	0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x02, 0xa4, 0x65, 0x61, 0x63, 0x65, 0x69, 0x64, 0x1b, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x67, 0x73, 0x75, 0x62, 0x6a,
	0x65, 0x63, 0x74, 0xa1, 0x68, 0x63, 0x6f, 0x6e, 0x6e, 0x74, 0x79, 0x70,
	0x65, 0x6a, 0x61, 0x75, 0x74, 0x68, 0x2d, 0x63, 0x72, 0x79, 0x70, 0x74,
	0x69, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x81, 0xa1,
	0x64, 0x68, 0x72, 0x65, 0x66, 0x6a, 0x2f, 0x6c, 0x69, 0x67, 0x68, 0x74,
	0x2f, 0x72, 0x65, 0x64, 0x6a, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73,
	0x69, 0x6f, 0x6e, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	0xa4, 0x65, 0x61, 0x63, 0x65, 0x69, 0x64, 0x1b, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03, 0x67, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74,
	0xa1, 0x64, 0x75, 0x75, 0x69, 0x64, 0x78, 0x24, 0x31, 0x31, 0x31, 0x31,
	0x31, 0x31, 0x31, 0x31, 0x2d, 0x31, 0x31, 0x31, 0x31, 0x2d, 0x31, 0x31,
	0x31, 0x31, 0x2d, 0x31, 0x31, 0x31, 0x31, 0x2d, 0x31, 0x31, 0x31, 0x31,
	0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x69, 0x72, 0x65, 0x73,
	0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x81, 0xa1, 0x64, 0x68, 0x72, 0x65,
	0x66, 0x6b, 0x2f, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x2f, 0x62, 0x6c, 0x75,
	0x65, 0x6a, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e,
	0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xa4, 0x65, 0x61,
	0x63, 0x65, 0x69, 0x64, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x04, 0x67, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0xa1, 0x64, 0x75,
	0x75, 0x69, 0x64, 0x78, 0x24, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
	0x32, 0x2d, 0x32, 0x32, 0x32, 0x32, 0x2d, 0x32, 0x32, 0x32, 0x32, 0x2d,
	0x32, 0x32, 0x32, 0x32, 0x2d, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
	0x32, 0x32, 0x32, 0x32, 0x32, 0x69, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72,
	0x63, 0x65, 0x73, 0x81, 0xa1, 0x64, 0x68, 0x72, 0x65, 0x66, 0x6b, 0x2f,
	0x6c, 0x69, 0x67, 0x68, 0x74, 0x2f, 0x62, 0x6c, 0x75, 0x65, 0x6a, 0x70,
	0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x1b, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x6a, 0x72, 0x6f, 0x77, 0x6e, 0x65,
	0x72, 0x75, 0x75, 0x69, 0x64, 0x78, 0x24, 0x34, 0x34, 0x34, 0x34, 0x34,
	0x34, 0x34, 0x34, 0x2d, 0x34, 0x34, 0x34, 0x34, 0x2d, 0x34, 0x34, 0x34,
	0x34, 0x2d, 0x34, 0x34, 0x34, 0x34, 0x2d, 0x34, 0x34, 0x34, 0x34, 0x34,
	0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34
};

const char TEMP_PSTAT_DATA[] = {
	0xa7, 0x63, 0x64, 0x6f, 0x73, 0xa2, 0x61, 0x73, 0x1b, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x03, 0x61, 0x70, 0xf4, 0x64, 0x69, 0x73, 0x6f,
	0x70, 0xf5, 0x62, 0x63, 0x6d, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x62, 0x74, 0x6d, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x62, 0x6f, 0x6d, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x62, 0x73, 0x6d, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x6a, 0x72, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x75, 0x75, 0x69,
	0x64, 0x78, 0x24, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x2d,
	0x34, 0x34, 0x34, 0x34, 0x2d, 0x34, 0x34, 0x34, 0x34, 0x2d, 0x34, 0x34,
	0x34, 0x34, 0x2d, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34,
	0x34, 0x34, 0x34
};

FILE *test_doxm_fopen(const char *path, const char *mode)
{
	(void)path;
	return fopen(TEMP_DOXM_PATH, mode);
}

FILE *test_cred_fopen(const char *path, const char *mode)
{
	(void)path;
	return fopen(TEMP_CRED_PATH, mode);
}

FILE *test_acl2_fopen(const char *path, const char *mode)
{
	(void)path;
	return fopen(TEMP_ACL2_PATH, mode);
}

FILE *test_pstat_fopen(const char *path, const char *mode)
{
	(void)path;
	return fopen(TEMP_PSTAT_PATH, mode);
}

void create_security_data_files(void)
{
	int fd;
	if (0 < (fd = open(TEMP_DOXM_PATH, O_WRONLY | O_CREAT, 0644))) {
		write(fd, TEMP_DOXM_DATA, sizeof(TEMP_DOXM_DATA));
		close(fd);
	}
	if (0 < (fd = open(TEMP_CRED_PATH, O_WRONLY | O_CREAT, 0644))) {
		write(fd, TEMP_CRED_DATA, sizeof(TEMP_CRED_DATA));
		close(fd);
	}
	if (0 < (fd = open(TEMP_ACL2_PATH, O_WRONLY | O_CREAT, 0644))) {
		write(fd, TEMP_ACL2_DATA, sizeof(TEMP_ACL2_DATA));
		close(fd);
	}
	if (0 < (fd = open(TEMP_PSTAT_PATH, O_WRONLY | O_CREAT, 0644))) {
		write(fd, TEMP_PSTAT_DATA, sizeof(TEMP_PSTAT_DATA));
		close(fd);
	}
}

void remove_security_data_files(void)
{
	unlink(TEMP_DOXM_PATH);
	unlink(TEMP_CRED_PATH);
	unlink(TEMP_ACL2_PATH);
	unlink(TEMP_PSTAT_PATH);
}

/* Generating SVR dat files */

typedef struct {
	const char *uri;
	ocf_resource_s resource;
	bool value;
	ocf_request_cb get;
	ocf_request_cb put;
	ocf_request_cb post;
	ocf_request_cb delete;
} ocf_item;

ocf_item blue_led = {.uri = "/light/blue" };
ocf_item red_led = {.uri = "/light/red" };

static bool is_separate = false;

static ocf_rep_encoder_s create_item_representation(ocf_item *item)
{
	ocf_rep_encoder_s rep = ocf_rep_encoder_init(OCF_REP_MAP);
	if (!rep) {
		printf("[%s]Can not make rep!! \n", __func__);
		return NULL;
	}

	ocf_rep_add_bool_to_map(rep, "value", item->value);
	return rep;
}

static void notifiy_item_state(ocf_item *item, int on)
{
	bool value = (on == 1 ? true : false);

	item->value = value;
	ocf_rep_encoder_s rep = create_item_representation(item);
	ocf_observe_notify(item->uri, rep);
	ocf_rep_encoder_release(rep);
	printf("[%s]Item Value Changed!!!!\n", __func__);
}

static ocf_result_t apply_interface_to_representation(ocf_request_s request, ocf_resource_s resource, ocf_rep_encoder_s rep)
{
	if (rep) {
		// ocf_request_query_set_s *queries = ocf_request_get_queries(request);
		ocf_res_add_if_rt_rep(rep, resource);
		return OCF_OK;
	}
	return OCF_ERROR;
}

static ocf_request_s *separate_store;
static void led_get_handler_func(ocf_item *item, ocf_request_s request)
{
	if (is_separate) {
		ocf_separate_accept(request, separate_store);

		// TODO: new thread
		is_separate = false;
		ocf_rep_encoder_s rep = create_item_representation(item);
		ocf_result_t ret = apply_interface_to_representation(request, item->resource, rep);
		if (ret == OCF_OK) {
			ocf_separate_resume(separate_store, rep, OCF_RESPONSE_CONTENT);
		} else {
			ocf_separate_resume(separate_store, NULL, OCF_RESPONSE_INTERNAL_SERVER_ERROR);
		}
		ocf_rep_encoder_release(rep);
	} else {
		ocf_rep_encoder_s rep = create_item_representation(item);
		ocf_result_t ret = apply_interface_to_representation(request, item->resource, rep);
		if (ret == OCF_OK) {
			ocf_response_send(request, rep, OCF_RESPONSE_CONTENT);
		} else {
			ocf_response_send(request, NULL, OCF_RESPONSE_INTERNAL_SERVER_ERROR);
		}
		ocf_rep_encoder_release(rep);
	}
}

static void blue_led_get_handler_func(ocf_request_s request, ocf_rep_decoder_s data)
{
	printf("Blue LED Receive GET Method\n");
	ocf_item *item = &blue_led;

	led_get_handler_func(item, request);
}

static void red_led_get_handler_func(ocf_request_s request, ocf_rep_decoder_s data)
{
	printf("Red LED Receive GET Method\n");
	ocf_item *item = &red_led;
	
	led_get_handler_func(item, request);
}

static void put_handler_func(ocf_request_s request, ocf_rep_decoder_s data)
{
	printf("Put request is received");
	ocf_response_send(request, NULL, OCF_RESPONSE_METHOD_NOT_ALLOWED);
}

static void led_post_handler_func(ocf_item *item, ocf_request_s request, ocf_rep_decoder_s data)
{
	if (!request) {
		printf("[%s]request is null\n", __func__);
		return;
	}

	bool value = 0;
	if (OCF_OK != ocf_rep_get_bool_from_map(data, "value", &value)) {
		ocf_response_send(request, NULL, OCF_RESPONSE_NOT_ACCEPTABLE);
		return;
	}

	printf("[%s]value : %d\n", __func__, value);
	item->value = value;

	ocf_rep_encoder_s rep = create_item_representation(item);
	if (rep) {
		ocf_request_query_set_s *queries = ocf_request_get_queries(request);
		if (queries->if_query && strcmp(OIC_IF_BASELINE_VALUE, queries->if_query) == 0) {
			ocf_res_add_if_rt_rep(rep, item->resource);
		}
		ocf_response_send(request, rep, OCF_RESPONSE_CHANGED);
		ocf_rep_encoder_release(rep);

		notifiy_item_state(item, value);
	} else {
		printf("[%s]Error : can't make representation properly\n", __func__);
		ocf_response_send(request, NULL, OCF_RESPONSE_INTERNAL_SERVER_ERROR);
	}
}

static void blue_led_post_handler_func(ocf_request_s request, ocf_rep_decoder_s data)
{
	printf("Blue LED receives POST Method\n");
	ocf_item *item = &blue_led;

	led_post_handler_func(item, request, data);
}

static void red_led_post_handler_func(ocf_request_s request, ocf_rep_decoder_s data)
{
	printf("Red LED receives POST Method\n");
	ocf_item *item = &red_led;
	
	led_post_handler_func(item, request, data);
}

static void delete_handler_func(ocf_request_s request, ocf_rep_decoder_s data)
{
	printf("Delete request is received");
	ocf_response_send(request, NULL, OCF_RESPONSE_METHOD_NOT_ALLOWED);
	return;
}

static void create_ocf_item_resource(ocf_item *item)
{
	item->resource = ocf_res_new_resource(item->uri);
	ocf_res_set_discoverable(item->resource, true);
	ocf_res_set_observable(item->resource, true);
	ocf_res_set_interface(item->resource, OIC_IF_BASELINE);
	ocf_res_set_default_interface(item->resource, OIC_IF_BASELINE);
	const char *item_resource_types[1] = { "core.light" };
	ocf_res_set_resource_types(item->resource, item_resource_types, 1);
	ocf_res_set_secure(item->resource, true);
	ocf_res_set_resource_protocol(item->resource, OCF_COAP | OCF_COAPS);
	ocf_res_set_request_handler(item->resource, OCF_GET, item->get);
	ocf_res_set_request_handler(item->resource, OCF_PUT, item->put);
	ocf_res_set_request_handler(item->resource, OCF_POST, item->post);
	ocf_res_set_request_handler(item->resource, OCF_DELETE, item->delete);
	ocf_res_register_resource(item->resource);
}

/* Set PS handler */
static ocf_persistent_storage_handler_s temp_doxm_handler = { test_doxm_fopen, fread, fwrite, fclose };
static ocf_persistent_storage_handler_s temp_cred_handler = { test_cred_fopen, fread, fwrite, fclose };
static ocf_persistent_storage_handler_s temp_acl2_handler = { test_acl2_fopen, fread, fwrite, fclose };
static ocf_persistent_storage_handler_s temp_pstat_handler = { test_pstat_fopen, fread, fwrite, fclose };

/* Set PS handler */
int main(int argc, char *argv[])
{
	setvbuf(stdout, (char *)NULL, _IOLBF, 0);

	create_security_data_files();
	ocf_sec_register_ps_handler(&temp_doxm_handler, &temp_pstat_handler, &temp_cred_handler, &temp_acl2_handler);

	ocf_init(OCF_SERVER, "Samsung", OCF_SH_100);

	const char *device_types[1] = { "oic.d.light" };
	ocf_core_add_oic_d_type(device_types, 1);

	blue_led.get = blue_led_get_handler_func;
	blue_led.put = put_handler_func;
	blue_led.post = blue_led_post_handler_func;
	blue_led.delete = delete_handler_func;
	blue_led.value = false;

	red_led.get = red_led_get_handler_func;
	red_led.put = put_handler_func;
	red_led.post = red_led_post_handler_func;
	red_led.delete = delete_handler_func;
	red_led.value = false;

	create_ocf_item_resource(&blue_led);
	create_ocf_item_resource(&red_led);

	int udp_secure_port = 0;
	int udp_normal_port = 0;

	rt_udp_get_secure_port_v4(&udp_secure_port);
	rt_udp_get_normal_port_v4(&udp_normal_port);

	printf("UDP dtls Port: %d\n", udp_secure_port);
	printf("UDP normal Port: %d\n", udp_normal_port);

	char key;
	int on;
	while (1) {
		printf("\n=====================================\n");
		printf("Blue Led : %s / Red Led : %s\n", (blue_led.value == true ? "on" : "off"), (red_led.value == true ? "on" : "off"));
		printf("=====================================\n");
		printf("Blue Led(b) / Red Led(r) / ");
		printf("Termination(q) / Termination without mem_terminate(w) : ");
		fflush(stdin);
		scanf("%c", &key);
		switch (key) {
		case 'b':
		case 'B':
			printf("Blue Led State(1:on/0:off) : ");
			fflush(stdin);
			scanf("%d", &on);
			notifiy_item_state(&blue_led, on);
			break;
		case 'r':
		case 'R':
			printf("Red Led State(1:on/0:off) : ");
			fflush(stdin);
			scanf("%d", &on);
			notifiy_item_state(&red_led, on);
			break;
		case 's':
		case 'S':
			printf("Seprate response ON");
			is_separate = true;
			break;
		case 'q':
		case 'Q':
			ocf_terminate();
			remove_security_data_files();
			return 0;
		default:
			break;
		}
	}
	return 1;
}
