/****************************************************************************
 *
 * Copyright 2017 Samsung Electronics All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 *
 ****************************************************************************/

#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <fcntl.h>

#include "ocf_types.h"
#include "ocf_resources.h"
#include "ocf_rep.h"
#include "ocf_request.h"

#include "rt_manager.h"
#include "rt_transport.h"
#include "rt_random.h"
#include "rt_receive_queue.h"
#include "rt_event.h"
#include "rt_core.h"
#include "rt_resources_manager.h"
#include "rt_rep.h"

/* Generating SVR dat files */
static const char TEMP_DOXM_PATH[] = "test_svr_doxm_server.dat";
static const char TEMP_CRED_PATH[] = "test_svr_cred_server.dat";
static const char TEMP_ACL2_PATH[] = "test_svr_acl2_server.dat";
static const char TEMP_PSTAT_PATH[] = "test_svr_pstat_server.dat";

const char TEMP_DOXM_DATA[] = {
	0xa7, 0x64, 0x6f, 0x78, 0x6d, 0x73, 0x81, 0x1b, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x66, 0x6f, 0x78, 0x6d, 0x73, 0x65, 0x6c, 0x1b,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x73, 0x63, 0x74,
	0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x65, 0x6f, 0x77,
	0x6e, 0x65, 0x64, 0xf5, 0x6a, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x75,
	0x75, 0x69, 0x64, 0x78, 0x24, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
	0x32, 0x2d, 0x32, 0x32, 0x32, 0x32, 0x2d, 0x32, 0x32, 0x32, 0x32, 0x2d,
	0x32, 0x32, 0x32, 0x32, 0x2d, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
	0x32, 0x32, 0x32, 0x32, 0x32, 0x6c, 0x64, 0x65, 0x76, 0x6f, 0x77, 0x6e,
	0x65, 0x72, 0x75, 0x75, 0x69, 0x64, 0x78, 0x24, 0x33, 0x33, 0x33, 0x33,
	0x33, 0x33, 0x33, 0x33, 0x2d, 0x33, 0x33, 0x33, 0x33, 0x2d, 0x33, 0x33,
	0x33, 0x33, 0x2d, 0x33, 0x33, 0x33, 0x33, 0x2d, 0x33, 0x33, 0x33, 0x33,
	0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6a, 0x72, 0x6f, 0x77,
	0x6e, 0x65, 0x72, 0x75, 0x75, 0x69, 0x64, 0x78, 0x24, 0x33, 0x33, 0x33,
	0x33, 0x33, 0x33, 0x33, 0x33, 0x2d, 0x33, 0x33, 0x33, 0x33, 0x2d, 0x33,
	0x33, 0x33, 0x33, 0x2d, 0x33, 0x33, 0x33, 0x33, 0x2d, 0x33, 0x33, 0x33,
	0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33
};

const char TEMP_CRED_DATA[] = {
	0xa2, 0x65, 0x63, 0x72, 0x65, 0x64, 0x73, 0x82, 0xa5, 0x66, 0x63, 0x72,
	0x65, 0x64, 0x69, 0x64, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x6b, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x75, 0x75, 0x69,
	0x64, 0x78, 0x24, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x2d,
	0x31, 0x31, 0x31, 0x31, 0x2d, 0x31, 0x31, 0x31, 0x31, 0x2d, 0x31, 0x31,
	0x31, 0x31, 0x2d, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
	0x31, 0x31, 0x31, 0x68, 0x63, 0x72, 0x65, 0x64, 0x74, 0x79, 0x70, 0x65,
	0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x66, 0x70, 0x65,
	0x72, 0x69, 0x6f, 0x64, 0x78, 0x1f, 0x32, 0x30, 0x31, 0x35, 0x30, 0x36,
	0x33, 0x30, 0x54, 0x30, 0x36, 0x30, 0x30, 0x30, 0x30, 0x2f, 0x32, 0x30,
	0x39, 0x39, 0x30, 0x39, 0x32, 0x30, 0x54, 0x32, 0x32, 0x30, 0x30, 0x30,
	0x30, 0x6b, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x64, 0x61, 0x74,
	0x61, 0xa2, 0x68, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x74,
	0x6f, 0x69, 0x63, 0x2e, 0x73, 0x65, 0x63, 0x2e, 0x65, 0x6e, 0x63, 0x6f,
	0x64, 0x69, 0x6e, 0x67, 0x2e, 0x72, 0x61, 0x77, 0x64, 0x64, 0x61, 0x74,
	0x61, 0x50, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0xa5, 0x66, 0x63, 0x72, 0x65, 0x64,
	0x69, 0x64, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x6b,
	0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x75, 0x75, 0x69, 0x64, 0x78,
	0x24, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x2d, 0x33, 0x33,
	0x33, 0x33, 0x2d, 0x33, 0x33, 0x33, 0x33, 0x2d, 0x33, 0x33, 0x33, 0x33,
	0x2d, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
	0x33, 0x68, 0x63, 0x72, 0x65, 0x64, 0x74, 0x79, 0x70, 0x65, 0x1b, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x66, 0x70, 0x65, 0x72, 0x69,
	0x6f, 0x64, 0x78, 0x1f, 0x32, 0x30, 0x31, 0x35, 0x30, 0x36, 0x33, 0x30,
	0x54, 0x30, 0x36, 0x30, 0x30, 0x30, 0x30, 0x2f, 0x32, 0x30, 0x39, 0x39,
	0x30, 0x39, 0x32, 0x30, 0x54, 0x32, 0x32, 0x30, 0x30, 0x30, 0x30, 0x6b,
	0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x64, 0x61, 0x74, 0x61, 0xa2,
	0x68, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x74, 0x6f, 0x69,
	0x63, 0x2e, 0x73, 0x65, 0x63, 0x2e, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69,
	0x6e, 0x67, 0x2e, 0x72, 0x61, 0x77, 0x64, 0x64, 0x61, 0x74, 0x61, 0x50,
	0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
	0x42, 0x42, 0x42, 0x42, 0x6a, 0x72, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x75,
	0x75, 0x69, 0x64, 0x78, 0x24, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
	0x33, 0x2d, 0x33, 0x33, 0x33, 0x33, 0x2d, 0x33, 0x33, 0x33, 0x33, 0x2d,
	0x33, 0x33, 0x33, 0x33, 0x2d, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
	0x33, 0x33, 0x33, 0x33, 0x33
};

const char TEMP_ACL2_DATA[] = {
	0xa2, 0x67, 0x61, 0x63, 0x6c, 0x69, 0x73, 0x74, 0x32, 0x82, 0xa4, 0x65,
	0x61, 0x63, 0x65, 0x69, 0x64, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x67, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0xa1, 0x68,
	0x63, 0x6f, 0x6e, 0x6e, 0x74, 0x79, 0x70, 0x65, 0x6a, 0x61, 0x6e, 0x6f,
	0x6e, 0x2d, 0x63, 0x6c, 0x65, 0x61, 0x72, 0x69, 0x72, 0x65, 0x73, 0x6f,
	0x75, 0x72, 0x63, 0x65, 0x73, 0x81, 0xa1, 0x62, 0x77, 0x63, 0x61, 0x2a,
	0x6a, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x1b,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xa4, 0x65, 0x61, 0x63,
	0x65, 0x69, 0x64, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	0x67, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0xa1, 0x68, 0x63, 0x6f,
	0x6e, 0x6e, 0x74, 0x79, 0x70, 0x65, 0x6a, 0x61, 0x75, 0x74, 0x68, 0x2d,
	0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72,
	0x63, 0x65, 0x73, 0x81, 0xa1, 0x62, 0x77, 0x63, 0x61, 0x2a, 0x6a, 0x70,
	0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x1b, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x6a, 0x72, 0x6f, 0x77, 0x6e, 0x65,
	0x72, 0x75, 0x75, 0x69, 0x64, 0x78, 0x24, 0x36, 0x31, 0x36, 0x34, 0x36,
	0x64, 0x36, 0x39, 0x2d, 0x36, 0x65, 0x34, 0x34, 0x2d, 0x36, 0x35, 0x37,
	0x36, 0x2d, 0x36, 0x39, 0x36, 0x33, 0x2d, 0x36, 0x35, 0x35, 0x35, 0x37,
	0x35, 0x36, 0x39, 0x36, 0x34, 0x33, 0x30
};

const char TEMP_PSTAT_DATA[] = {
	0xBF, 0x63, 0x64, 0x6F, 0x73, 0xA2, 0x61, 0x73, 0x01, 0x61, 0x70, 0xF4, 0x64, 0x69, 0x73, 0x6F,
	0x70, 0xF4, 0x62, 0x63, 0x6D, 0x02, 0x62, 0x74, 0x6D, 0x00, 0x62, 0x6F, 0x6D, 0x04, 0x62, 0x73,
	0x6D, 0x04, 0x6A, 0x72, 0x6F, 0x77, 0x6E, 0x65, 0x72, 0x75, 0x75, 0x69, 0x64, 0x78, 0x24, 0x31,
	0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x2D, 0x31, 0x31, 0x31, 0x31, 0x2D, 0x31, 0x31, 0x31,
	0x31, 0x2D, 0x31, 0x31, 0x31, 0x31, 0x2D, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
	0x31, 0x31, 0x31, 0xFF
};

FILE *test_doxm_fopen(const char *path, const char *mode)
{
	(void)path;
	return fopen(TEMP_DOXM_PATH, mode);
}

FILE *test_cred_fopen(const char *path, const char *mode)
{
	(void)path;
	return fopen(TEMP_CRED_PATH, mode);
}

FILE *test_acl2_fopen(const char *path, const char *mode)
{
	(void)path;
	return fopen(TEMP_ACL2_PATH, mode);
}

FILE *test_pstat_fopen(const char *path, const char *mode)
{
	(void)path;
	return fopen(TEMP_PSTAT_PATH, mode);
}

void create_security_data_files(void)
{
	int fd;
	if (0 < (fd = open(TEMP_DOXM_PATH, O_WRONLY | O_CREAT, 0644))) {
		write(fd, TEMP_DOXM_DATA, sizeof(TEMP_DOXM_DATA));
		close(fd);
	}
	if (0 < (fd = open(TEMP_CRED_PATH, O_WRONLY | O_CREAT, 0644))) {
		write(fd, TEMP_CRED_DATA, sizeof(TEMP_CRED_DATA));
		close(fd);
	}
	if (0 < (fd = open(TEMP_ACL2_PATH, O_WRONLY | O_CREAT, 0644))) {
		write(fd, TEMP_ACL2_DATA, sizeof(TEMP_ACL2_DATA));
		close(fd);
	}
	if (0 < (fd = open(TEMP_PSTAT_PATH, O_WRONLY | O_CREAT, 0644))) {
		write(fd, TEMP_PSTAT_DATA, sizeof(TEMP_PSTAT_DATA));
		close(fd);
	}
}

void remove_security_data_files(void)
{
	unlink(TEMP_DOXM_PATH);
	unlink(TEMP_CRED_PATH);
	unlink(TEMP_ACL2_PATH);
	unlink(TEMP_PSTAT_PATH);
}

/* Generating SVR dat files */

#define TAG "SIMPLE_SERVER"
#define COLOR_LENTH 10

static bool binary_switch;
static int brightness;

const char *brightness_uri = "/brightness";
const char *binary_switch_uri = "/binarySwitch";
ocf_resource_s binary_switch_resource;
ocf_resource_s brightness_resource;
// TODO: encoding cbor would provide flexible size in future
#define ENCODER_MAP_LEN 1024
#define ENCODER_ARRAY_LEN 100

static ocf_rep_encoder_s create_binary_switch_representation(void)
{
	ocf_rep_encoder_s rep = ocf_rep_encoder_init(OCF_REP_MAP);
	if (!rep) {
		return NULL;
	}

	ocf_rep_add_bool_to_map(rep, "value", binary_switch);
	return rep;
}

static ocf_rep_encoder_s create_brightness_representation(void)
{
	ocf_rep_encoder_s rep = ocf_rep_encoder_init(OCF_REP_MAP);
	if (!rep) {
		return NULL;
	}

	ocf_rep_add_int_to_map(rep, "brightness", brightness);
	return rep;
}

static void binary_switch_get_handler_func(ocf_request_s request, ocf_rep_decoder_s data)
{
	printf("Receive GET Method\n");

	ocf_rep_encoder_s rep = create_binary_switch_representation();
	if (rep) {
		ocf_request_query_set_s *queries = ocf_request_get_queries(request);
		if (queries->if_query && strcmp(OIC_IF_BASELINE_VALUE, queries->if_query) == 0) {
			ocf_res_add_if_rt_rep(rep, binary_switch_resource);
		}
		ocf_response_send(request, rep, OCF_RESPONSE_CONTENT);
		ocf_rep_encoder_release(rep);
	} else {
		ocf_response_send(request, NULL, OCF_RESPONSE_RESOURCE_NOT_FOUND);
	}
}

static void put_handler_func(ocf_request_s request, ocf_rep_decoder_s data)
{
	printf("Put request is received");
	ocf_response_send(request, NULL, OCF_RESPONSE_METHOD_NOT_ALLOWED);
	return;
}

static ocf_result_t apply_interface_to_representation(ocf_request_s request, ocf_resource_s resource, ocf_rep_encoder_s *rep)
{
	if (rep) {
		ocf_request_query_set_s *queries = ocf_request_get_queries(request);
		if (queries->if_query && strcmp(OIC_IF_BASELINE_VALUE, queries->if_query) == 0) {
			ocf_res_add_if_rt_rep(rep, resource);
		}
		return OCF_OK;
	}
	return OCF_ERROR;
}

static void binary_switch_post_handler_func(ocf_request_s request, ocf_rep_decoder_s data)
{
	printf("binary_switch receives POST Method\n");
	if (!request) {
		printf("request is null\n");
		return;
	}

	bool value = 0;
	if (OCF_OK == ocf_rep_get_bool_from_map(data, "value", &value)) {
		printf("value : %d\n", value);
		binary_switch = value;

		ocf_rep_encoder_s rep = create_binary_switch_representation();
		if (rep) {
			ocf_request_query_set_s *queries = ocf_request_get_queries(request);
			if (queries->if_query && strcmp(OIC_IF_BASELINE_VALUE, queries->if_query) == 0) {
				ocf_res_add_if_rt_rep(rep, binary_switch_resource);
			}
			ocf_response_send(request, rep, OCF_RESPONSE_CHANGED);
			ocf_rep_encoder_release(rep);
			return;
		}
	}
	ocf_response_send(request, NULL, OCF_RESPONSE_NOT_ACCEPTABLE);
}

static void delete_handler_func(ocf_request_s request, ocf_rep_decoder_s data)
{
	printf("Delete request is received");
	ocf_response_send(request, NULL, OCF_RESPONSE_METHOD_NOT_ALLOWED);
	return;
}

static void brightness_get_handler_func(ocf_request_s request, ocf_rep_decoder_s data)
{
	printf("brightness receives GET Method\n");

	ocf_rep_encoder_s rep = create_brightness_representation();
	if (rep) {
		ocf_request_query_set_s *queries = ocf_request_get_queries(request);
		if (queries->if_query && strcmp(OIC_IF_BASELINE_VALUE, queries->if_query) == 0) {
			ocf_res_add_if_rt_rep(rep, binary_switch_resource);
		}
		ocf_response_send(request, rep, OCF_RESPONSE_CONTENT);
		ocf_rep_encoder_release(rep);

	} else {
		ocf_response_send(request, NULL, OCF_RESPONSE_FORBIDDEN);
	}
}

static void notifiy_brightness(void)
{
	if (brightness == 0) {
		brightness = 100;
	} else {
		--brightness;
	}

	ocf_rep_encoder_s rep = create_brightness_representation();
	ocf_observe_notify(brightness_uri, rep);
	ocf_rep_encoder_release(rep);
	printf("[%s]Item Value Changed!!!!\n", __func__);
}

static void brightness_post_handler_func(ocf_request_s request, ocf_rep_decoder_s data)
{
	printf("brightness receives POST Method\n");
	if (!request) {
		printf("request is null\n");
		return;
	}

	int value = 0;
	if (OCF_OK == ocf_rep_get_int_from_map(data, "brightness", &value)) {
		printf("brightness : %d\n", value);
		brightness = value;

		ocf_rep_encoder_s rep = create_brightness_representation();
		if (rep) {
			ocf_request_query_set_s *queries = ocf_request_get_queries(request);
			if (queries->if_query && strcmp(OIC_IF_BASELINE_VALUE, queries->if_query) == 0) {
				ocf_res_add_if_rt_rep(rep, binary_switch_resource);
			}
			ocf_response_send(request, rep, OCF_RESPONSE_CHANGED);
			notifiy_brightness();
			ocf_rep_encoder_release(rep);
			return;
		}
	}
	ocf_response_send(request, NULL, OCF_RESPONSE_NOT_ACCEPTABLE);
}

void create_sample_resource(void)
{
	binary_switch_resource = ocf_res_new_resource(binary_switch_uri);
	ocf_res_set_discoverable(binary_switch_resource, true);
	ocf_res_set_observable(binary_switch_resource, false);
	ocf_res_set_interface(binary_switch_resource, OIC_IF_A | OIC_IF_BASELINE);
	ocf_res_set_default_interface(binary_switch_resource, OIC_IF_A);
	const char *binary_switch_resource_types[1] = { "oic.r.switch.binary" };
	ocf_res_set_resource_types(binary_switch_resource, binary_switch_resource_types, 1);
	ocf_res_set_secure(binary_switch_resource, true);
	ocf_res_set_resource_protocol(binary_switch_resource, OCF_COAP | OCF_COAP_TCP);
	ocf_res_set_request_handler(binary_switch_resource, OCF_GET, binary_switch_get_handler_func);
	ocf_res_set_request_handler(binary_switch_resource, OCF_PUT, put_handler_func);
	ocf_res_set_request_handler(binary_switch_resource, OCF_POST, binary_switch_post_handler_func);
	ocf_res_set_request_handler(binary_switch_resource, OCF_DELETE, delete_handler_func);
	ocf_res_register_resource(binary_switch_resource);

	brightness_resource = ocf_res_new_resource(brightness_uri);
	ocf_res_set_discoverable(brightness_resource, true);
	ocf_res_set_observable(brightness_resource, true);
	ocf_res_set_interface(brightness_resource, OIC_IF_A | OIC_IF_BASELINE);
	ocf_res_set_default_interface(brightness_resource, OIC_IF_A);
	const char *brightness_resource_types[1] = { "oic.r.light.brightness" };
	ocf_res_set_resource_types(brightness_resource, brightness_resource_types, 1);
	ocf_res_set_secure(brightness_resource, true);
	ocf_res_set_resource_protocol(brightness_resource, OCF_COAP | OCF_COAP_TCP);
	ocf_res_set_request_handler(brightness_resource, OCF_GET, brightness_get_handler_func);
	ocf_res_set_request_handler(brightness_resource, OCF_PUT, put_handler_func);
	ocf_res_set_request_handler(brightness_resource, OCF_POST, brightness_post_handler_func);
	ocf_res_set_request_handler(brightness_resource, OCF_DELETE, delete_handler_func);
	ocf_res_register_resource(brightness_resource);
	brightness = 100;
	rt_core_set_oic_d_name_opt("SmartLight");
}

static void set_default_values(void)
{
	brightness = 100;
	binary_switch = false;
}

/* Set PS handler */
static ocf_persistent_storage_handler_s temp_doxm_handler = { test_doxm_fopen, fread, fwrite, fclose };
static ocf_persistent_storage_handler_s temp_cred_handler = { test_cred_fopen, fread, fwrite, fclose };
static ocf_persistent_storage_handler_s temp_acl2_handler = { test_acl2_fopen, fread, fwrite, fclose };
static ocf_persistent_storage_handler_s temp_pstat_handler = { test_pstat_fopen, fread, fwrite, fclose };

/* Set PS handler */

int main(int argc, char *argv[])
{
	setvbuf(stdout, (char *)NULL, _IOLBF, 0);

	create_security_data_files();
	ocf_sec_register_ps_handler(&temp_doxm_handler, &temp_pstat_handler, &temp_cred_handler, &temp_acl2_handler);

	ocf_init(OCF_SERVER, "Samsung", OCF_SH_100);

	const char *device_types[1] = { "oic.d.light" };
	ocf_core_add_oic_d_type(device_types, 1);
	set_default_values();
	create_sample_resource();

	int udp_secure_port = 0;
	int udp_normal_port = 0;

	rt_udp_get_secure_port_v4(&udp_secure_port);
	rt_udp_get_normal_port_v4(&udp_normal_port);

	printf("UDP dtls Port: %d\n", udp_secure_port);
	printf("UDP normal Port: %d\n", udp_normal_port);

	char key;
	while (1) {
		printf("Notify(n) / Termination(q) / Termination without mem_terminate(w) : ");
		scanf("%c", &key);
		fflush(stdin);
		switch (key) {
		case 'n':
		case 'N':
			notifiy_brightness();
			break;

		case 'q':
		case 'Q':
			ocf_terminate();
			remove_security_data_files();
			return 0;
		default:
			break;
		}
	}
	return 1;
}
